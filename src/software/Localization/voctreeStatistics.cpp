/* 
 * File:   voctreeStatistics.cpp
 * Author: jeme
 *
 * Created on 21 octobre 2015, 16:51
 */


#include <openMVG/sfm/sfm_data_io.hpp>
#include <openMVG/voctree/database.hpp>
#include <openMVG/voctree/databaseIO.hpp>
#include <openMVG/voctree/vocabulary_tree.hpp>
#include <openMVG/voctree/descriptor_loader.hpp>

#include <boost/program_options.hpp> 
#include <boost/accumulators/accumulators.hpp>
#include <boost/accumulators/statistics/tail.hpp>

#include <Eigen/Core>

#include <iostream>
#include <fstream>
#include <ostream>
#include <string>
#include <chrono>
#include <iomanip>

#define POPART_COUT(x) std::cout << x << std::endl
#define POPART_CERR(x) std::cerr << x << std::endl

static const int DIMENSION = 128;

using namespace std;
using namespace boost::accumulators;
namespace bpo = boost::program_options;
namespace bfs = boost::filesystem;

typedef openMVG::features::Descriptor<float, DIMENSION> DescriptorFloat;
typedef openMVG::features::Descriptor<unsigned char, DIMENSION> DescriptorUChar;

typedef std::map<size_t, openMVG::voctree::Document> DocumentMap;

std::ostream& operator<<(std::ostream& os, const openMVG::voctree::DocMatches &matches)
{
  os << "[ ";
  for(const auto &e : matches)
  {
    os << e.id << ", " << e.score << "; ";
  }
  os << "];\n";
  return os;
}

std::ostream& operator<<(std::ostream& os, const openMVG::voctree::Document &doc)
{
  os << "[ ";
  for(const openMVG::voctree::Word &w : doc)
  {
    os << w << ", ";
  }
  os << "];\n";
  return os;
}

std::string myToString(std::size_t i, std::size_t zeroPadding)
{
  stringstream ss;
  ss << std::setw(zeroPadding) << std::setfill('0') << i;
  return ss.str();
}

bool saveDocumentMap(const std::string &filename, const DocumentMap &docs)
{
  std::ofstream fileout(filename);
  if(!fileout.is_open())
    return false;

  for(const auto &d : docs)
  {
    fileout << "d{" << d.first << "} = " << d.second << "\n";
  }

  fileout.close();
  return true;
}

static const std::string programDescription =
        "This program is used to generate some statistics.\n ";

/*
 * This program is used to create a database with a provided dataset of image descriptors using a trained vocabulary tree
 * The database is then queried with the same images in order to retrieve for each image the set of most similar images in the dataset
 */
int main(int argc, char** argv)
{
   
  int verbosity = 1; ///< verbosity level
  string weightsName; ///< the filename for the voctree weights
  bool withWeights = false; ///< flag for the optional weights file
  string treeName; ///< the filename of the voctree
  string keylist; ///< the file containing the list of features to use to build the database
  string queryList = ""; ///< the file containing the list of features to use as query
  size_t numImageQuery; ///< the number of matches to retrieve for each image
  string distance;

  openMVG::sfm::SfM_Data sfmdata;
  openMVG::sfm::SfM_Data *sfmdataQuery;

  bpo::options_description desc(programDescription);
  desc.add_options()
          ("help,h", "Print this message")
          ("verbose,v", bpo::value<int>(&verbosity)->default_value(1), "Verbosity level, 0 to mute")
          ("weights,w", bpo::value<string>(&weightsName), "Input name for the weight file, if not provided the weights will be computed on the database built with the provided set")
          ("tree,t", bpo::value<string>(&treeName)->required(), "Input name for the tree file")
          ("keylist,l", bpo::value<string>(&keylist)->required(), "Path to the list file generated by OpenMVG containing the features to use for building the database")
          ("querylist,q", bpo::value<string>(&queryList), "Path to the list file to be used for querying the database")
          ("distance,d",bpo::value<string>(&distance)->default_value(""), "Method used to compute distance between histograms: \n "
                                                                                "-classic: eucledian distance \n"
                                                                                "-commonPoints: counts common points between histograms \n"
                                                                                "-strongCommonPoints: counts common 1 values \n"
                                                                                "-weightedStrongCommonPoints: strongCommonPoints with weights \n"
                                                                                "-inversedWeightedCommonPoints: strongCommonPoints with inverted weights");
  


  bpo::variables_map vm;

  try
  {
    bpo::store(bpo::parse_command_line(argc, argv, desc), vm);

    if(vm.count("help") || (argc == 1))
    {
      std::cout << desc << std::endl;
      return EXIT_SUCCESS;
    }

    bpo::notify(vm);
  }
  catch(bpo::required_option& e)
  {
    std::cerr << "ERROR: " << e.what() << std::endl << std::endl;
    std::cout << "Usage:\n\n" << desc << std::endl;
    return EXIT_FAILURE;
  }
  catch(bpo::error& e)
  {
    std::cerr << "ERROR: " << e.what() << std::endl << std::endl;
    std::cout << "Usage:\n\n" << desc << std::endl;
    return EXIT_FAILURE;
  }

  if(vm.count("weights"))
  {
    withWeights = true;
  }

  

  //************************************************
  // Load vocabulary tree
  //************************************************

  POPART_COUT("Loading vocabulary tree\n");
  openMVG::voctree::VocabularyTree<DescriptorFloat> tree(treeName);
  POPART_COUT("tree loaded with\n\t" 
          << tree.levels() << " levels\n\t" 
          << tree.splits() << " branching factor");


  //************************************************
  // Create the database
  //************************************************

  POPART_COUT("Creating the database...");
  // Add each object (document) to the database
  openMVG::voctree::Database db(tree.words());

  if(withWeights)
  {
    POPART_COUT("Loading weights...");
    db.loadWeights(weightsName);
  }
  else
  {
    POPART_COUT("No weights specified, skipping...");
  }


  //*********************************************************
  // Read the descriptors and populate the database
  //*********************************************************

  POPART_COUT("Reading descriptors from " << keylist);
  DocumentMap documents;

  auto detect_start = std::chrono::steady_clock::now();
  size_t numTotFeatures = openMVG::voctree::populateDatabase<DescriptorUChar>(keylist, tree, db, documents);
  auto detect_end = std::chrono::steady_clock::now();
  auto detect_elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(detect_end - detect_start);

  if(numTotFeatures == 0)
  {
    POPART_CERR("No descriptors loaded!!");
    return EXIT_FAILURE;
  }

  POPART_COUT("Done! " << documents.size() << " sets of descriptors read for a total of " << numTotFeatures << " features");
  POPART_COUT("Reading took " << detect_elapsed.count() << " sec");
  

  if(!withWeights)
  {
    // Compute and save the word weights
    POPART_COUT("Computing weights...");
    db.computeTfIdfWeights();
  }


  //************************************************
  // Query documents for Statistics
  //************************************************

  std::map<int,int> globalHisto;

  POPART_COUT("Getting some stats for " << queryList);
  
  openMVG::voctree::voctreeStatistics<DescriptorUChar>(queryList, tree, db, distance, globalHisto);
  
  std::cout << "-----------------" << std::endl;
  
  for(auto itHisto = globalHisto.begin(); itHisto != globalHisto.end(); itHisto++)
    {
      std::cout << itHisto->first << ": " << itHisto->second  << ", ";
    }
    std::cout << std::endl;
  

  return EXIT_SUCCESS;
}
